diff --git a/src/entity_data.zig b/src/entity_data.zig
index 8a30c1ad..12a63191 100644
--- a/src/entity_data.zig
+++ b/src/entity_data.zig
@@ -10,6 +10,7 @@ const getIndex = main.chunk.getIndex;
 const server = main.server;
 const User = server.User;
 const mesh_storage = main.renderer.mesh_storage;
+const ChestParams = main.gui.windowlist.chest.ChestParams;
 
 pub const EntityDataClass = struct {
 	id: []const u8,
@@ -173,16 +174,16 @@ fn BlockEntityDataStorage(comptime side: enum {client, server}, T: type) type {
 
 pub const EntityDataClasses = struct {
 	pub const Chest = struct {
-		const StorageServer = BlockEntityDataStorage(
+		pub const StorageServer = BlockEntityDataStorage(
 			.server,
 			struct {
-				inventoryId: u64,
+				inventoryId: ?u32,
 			},
 		);
-		const StorageClient = BlockEntityDataStorage(
+		pub const StorageClient = BlockEntityDataStorage(
 			.client,
 			struct {
-				inventoryId: u64,
+				inventoryId: ?u32,
 			},
 		);
 
@@ -203,8 +204,16 @@ pub const EntityDataClasses = struct {
 		pub fn onLoadClient(_: Vec3i, _: *Chunk) void {
 			std.log.debug("Chest.onLoadClient", .{});
 		}
-		pub fn onUnloadClient(_: Vec3i, _: *Chunk) void {
+		pub fn onUnloadClient(pos: Vec3i, chunk: *Chunk) void {
 			std.log.debug("Chest.onUnloadClient", .{});
+
+			StorageClient.mutex.lock();
+			defer StorageClient.mutex.unlock();
+
+			const data = StorageClient.get(pos, chunk);
+			main.items.Inventory.Sync.getInventory(data.?.inventoryId, .client, null).?.deinit(main.globalAllocator);
+
+			StorageClient.remove(pos, chunk);
 		}
 		pub fn onLoadServer(_: Vec3i, _: *Chunk) void {
 			std.log.debug("Chest.onLoadServer", .{});
@@ -229,12 +238,30 @@ pub const EntityDataClasses = struct {
 			StorageServer.remove(pos, chunk);
 		}
 		pub fn onInteract(pos: Vec3i, chunk: *Chunk) EventStatus {
+			if(main.KeyBoard.key("shift").pressed) return .ignored;
 			StorageClient.mutex.lock();
 			defer StorageClient.mutex.unlock();
-			const data = StorageClient.get(pos, chunk);
-			if(data == null) std.log.debug("Chest.onInteract: null", .{}) else std.log.debug("Chest.onInteract: {}", .{data.?.contents});
-			
-			main.gui.openWindow("chest");
+
+			std.debug.assert(StorageClient.get(pos, chunk) == null);
+
+			const block = main.renderer.mesh_storage.getBlock(pos[0], pos[1], pos[2]).?;
+			// TODO: pass inventory size as a parameter!
+			const inventory = main.items.Inventory.init(main.globalAllocator, block.inventorySize().?, .{.blockInventory = pos}, .{.blockInventory = pos});
+			// TODO: Populate from server side storage?
+			StorageClient.mutex.lock();
+			defer StorageClient.mutex.unlock();
+
+			StorageClient.add(pos, .{.inventoryId = inventory.id}, chunk);
+
+			const data = StorageClient.get(pos, chunk) orelse unreachable;
+			const params = ChestParams{
+				.pos = pos,
+				.inventoryId = data.inventoryId,
+			};
+
+			// TODO: likely we would want to allow specifying the GUI based on block.gui() but with some error checking.
+			main.gui.openWindowParams("chest", &params);
+			main.Window.setMouseGrabbed(false);
 
 			return .handled;
 		}
diff --git a/src/gui/GuiWindow.zig b/src/gui/GuiWindow.zig
index 73531956..633781d4 100644
--- a/src/gui/GuiWindow.zig
+++ b/src/gui/GuiWindow.zig
@@ -73,6 +73,7 @@ updateSelectedFn: *const fn() void = &defaultFunction,
 updateHoveredFn: *const fn() void = &defaultFunction,
 
 onOpenFn: *const fn() void = &defaultFunction,
+onOpenParamsFn: *const fn(*anyopaque) void = &defaultFunctionParams,
 
 onCloseFn: *const fn() void = &defaultFunction,
 
@@ -129,6 +130,8 @@ pub fn __deinit() void {
 
 pub fn defaultFunction() void {}
 
+pub fn defaultFunctionParams(_: *anyopaque) void {}
+
 pub fn mainButtonPressed(self: *const GuiWindow, mousePosition: Vec2f) void {
 	const scaledMousePos = (mousePosition - self.pos)/@as(Vec2f, @splat(self.scale));
 	const btnPos = self.getButtonPositions();
diff --git a/src/gui/gui.zig b/src/gui/gui.zig
index d674d84c..404a3faf 100644
--- a/src/gui/gui.zig
+++ b/src/gui/gui.zig
@@ -45,6 +45,7 @@ const GuiCommandQueue = struct { // MARK: GuiCommandQueue
 	const Command = struct {
 		window: *GuiWindow,
 		action: Action,
+		params: ?*anyopaque,
 	};
 
 	var commands: main.utils.ConcurrentQueue(Command) = undefined;
@@ -65,16 +66,17 @@ const GuiCommandQueue = struct { // MARK: GuiCommandQueue
 		while(commands.dequeue()) |command| {
 			switch(command.action) {
 				.open => {
-					executeOpenWindowCommand(command.window);
+					executeOpenWindowCommand(command.window, command.params);
 				},
 				.close => {
+					std.debug.assert(command.params == null);
 					executeCloseWindowCommand(command.window);
 				},
 			}
 		}
 	}
 
-	fn executeOpenWindowCommand(window: *GuiWindow) void {
+	fn executeOpenWindowCommand(window: *GuiWindow, _params: ?*anyopaque) void {
 		defer updateWindowPositions();
 		for(openWindows.items, 0..) |_openWindow, i| {
 			if(_openWindow == window) {
@@ -85,7 +87,11 @@ const GuiCommandQueue = struct { // MARK: GuiCommandQueue
 			}
 		}
 		openWindows.append(window);
-		window.onOpenFn();
+		if(_params) |params| {
+			window.onOpenParamsFn(params);
+		} else {
+			window.onOpenFn();
+		}
 		selectedWindow = null;
 	}
 
@@ -304,17 +310,34 @@ fn addWindow(window: *GuiWindow) void {
 pub fn openWindow(id: []const u8) void {
 	defer updateWindowPositions();
 
+	const window = getWindow(id) orelse {
+		std.log.err("Could not find window with id {s}.", .{id});
+		return;
+	};
+	openWindowFromRef(window, null);
+}
+
+pub fn getWindow(id: []const u8) ?*GuiWindow {
 	for(windowList.items) |window| {
 		if(std.mem.eql(u8, window.id, id)) {
-			openWindowFromRef(window);
-			return;
+			return window;
 		}
 	}
-	std.log.err("Could not find window with id {s}.", .{id});
+	return null;
+}
+
+pub fn openWindowParams(id: []const u8, params: *anyopaque) void {
+	defer updateWindowPositions();
+
+	const window = getWindow(id) orelse {
+		std.log.err("Could not find window with id {s}.", .{id});
+		return;
+	};
+	openWindowFromRef(window, params);
 }
 
-pub fn openWindowFromRef(window: *GuiWindow) void {
-	GuiCommandQueue.scheduleCommand(.{.action = .open, .window = window});
+pub fn openWindowFromRef(window: *GuiWindow, params: ?*anyopaque) void {
+	GuiCommandQueue.scheduleCommand(.{.action = .open, .window = window, .params = params});
 }
 
 pub fn toggleWindow(id: []const u8) void {
@@ -349,7 +372,7 @@ pub fn openHud() void {
 }
 
 fn openWindowCallbackFunction(windowPtr: usize) void {
-	openWindowFromRef(@ptrFromInt(windowPtr));
+	openWindowFromRef(@ptrFromInt(windowPtr), null);
 }
 pub fn openWindowCallback(comptime id: []const u8) Callback {
 	return .{
@@ -359,7 +382,7 @@ pub fn openWindowCallback(comptime id: []const u8) Callback {
 }
 
 pub fn closeWindowFromRef(window: *GuiWindow) void {
-	GuiCommandQueue.scheduleCommand(.{.action = .close, .window = window});
+	GuiCommandQueue.scheduleCommand(.{.action = .close, .window = window, .params = null});
 }
 
 pub fn closeWindow(id: []const u8) void {
diff --git a/src/gui/windows/chest.zig b/src/gui/windows/chest.zig
index 8d13dcd8..e9ffb93d 100644
--- a/src/gui/windows/chest.zig
+++ b/src/gui/windows/chest.zig
@@ -1,6 +1,6 @@
 const std = @import("std");
 
-const main = @import("root");
+const main = @import("main");
 const Player = main.game.Player;
 const ItemStack = main.items.ItemStack;
 const Vec2f = main.vec.Vec2f;
@@ -27,8 +27,8 @@ pub var window = GuiWindow{
 };
 
 const padding: f32 = 8;
-
 var itemSlots: main.List(*ItemSlot) = undefined;
+var blockPos: main.vec.Vec3i = undefined;
 
 pub fn init() void {
 	itemSlots = .init(main.globalAllocator);
@@ -40,13 +40,17 @@ pub fn deinit() void {
 
 pub var openInventory: main.items.Inventory = undefined;
 
-pub fn onOpen() void {
-	const blockPos = main.renderer.MeshSelection.selectedBlockPos.?;
-	const block = main.renderer.mesh_storage.getBlock(blockPos[0], blockPos[1], blockPos[2]).?;
-	openInventory = main.items.Inventory.init(main.globalAllocator, block.inventorySize().?, .{.blockInventory = blockPos}, .{.blockInventory = blockPos});
+pub const ChestParams = struct {
+	pos: main.vec.Vec3i,
+	inventoryId: u32,
+};
+
+pub fn onOpenParams(_params: *anyopaque) void {
+	const params: *ChestParams = @ptrCast(_params);
+	openInventory = main.items.Inventory.Sync.getInventory(params.inventoryId, .client, null);
 
 	const list = VerticalList.init(.{padding, padding + 16}, 300, 0);
-	// Some miscellanious slots and buttons:
+	// Some miscellaneous slots and buttons:
 	// TODO: armor slots, backpack slot + stack-based backpack inventory, other items maybe?
 	for(0..1) |y| {
 		const row = HorizontalList.init();
@@ -65,7 +69,10 @@ pub fn onOpen() void {
 }
 
 pub fn onClose() void {
-	openInventory.deinit(main.globalAllocator);
+	const block = main.renderer.mesh_storage.getBlock(blockPos[0], blockPos[1], blockPos[2]).?;
+	const mesh = main.renderer.mesh_storage.getMeshAndIncreaseRefCount(.initFromWorldPos(blockPos, 1)).?;
+	block.entityDataClass().?.onUnloadClient(blockPos, mesh.chunk);
+
 	itemSlots.clearRetainingCapacity();
 	if(window.rootComponent) |*comp| {
 		comp.deinit();
