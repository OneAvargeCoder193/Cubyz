diff --git a/assets/cubyz/blocks/chest/_defaults.zig.zon b/assets/cubyz/blocks/chest/_defaults.zig.zon
index f1aa873c..5d716975 100644
--- a/assets/cubyz/blocks/chest/_defaults.zig.zon
+++ b/assets/cubyz/blocks/chest/_defaults.zig.zon
@@ -4,7 +4,11 @@
 	.drops = .{
 		.{.items = .{.auto}},
 	},
-	.model = "cubyz:cube",
-	.rotation = "cubyz:planar",
+	.model = .{
+		.closed = "cubyz:cube",
+		.open = "cubyz:open_chest",
+		.lid = "cubyz:chest_lid",
+	},
+	.rotation = "cubyz:chest",
 	.blockEntity = .chest,
 }
diff --git a/assets/cubyz/blocks/chest/baobab.zig.zon b/assets/cubyz/blocks/chest/baobab.zig.zon
index e53ce512..b9cb9442 100644
--- a/assets/cubyz/blocks/chest/baobab.zig.zon
+++ b/assets/cubyz/blocks/chest/baobab.zig.zon
@@ -5,4 +5,6 @@
 	.texture_right = "cubyz:chest/baobab/side",
 	.texture_top = "cubyz:chest/baobab/top",
 	.texture_bottom = "cubyz:chest/baobab/bottom",
+	.texture6 = "cubyz:void_stone",
+	.texture7 = "cubyz:void_stone",
 }
diff --git a/assets/cubyz/blocks/chest/birch.zig.zon b/assets/cubyz/blocks/chest/birch.zig.zon
index 827432a1..64f21705 100644
--- a/assets/cubyz/blocks/chest/birch.zig.zon
+++ b/assets/cubyz/blocks/chest/birch.zig.zon
@@ -5,4 +5,6 @@
 	.texture_right = "cubyz:chest/birch/side",
 	.texture_top = "cubyz:chest/birch/top",
 	.texture_bottom = "cubyz:chest/birch/bottom",
+	.texture6 = "cubyz:void_stone",
+	.texture7 = "cubyz:void_stone",
 }
diff --git a/assets/cubyz/blocks/chest/mahogany.zig.zon b/assets/cubyz/blocks/chest/mahogany.zig.zon
index 619242a6..e7408010 100644
--- a/assets/cubyz/blocks/chest/mahogany.zig.zon
+++ b/assets/cubyz/blocks/chest/mahogany.zig.zon
@@ -5,4 +5,6 @@
 	.texture_right = "cubyz:chest/mahogany/side",
 	.texture_top = "cubyz:chest/mahogany/top",
 	.texture_bottom = "cubyz:chest/mahogany/bottom",
+	.texture6 = "cubyz:void_stone",
+	.texture7 = "cubyz:void_stone",
 }
diff --git a/assets/cubyz/blocks/chest/oak.zig.zon b/assets/cubyz/blocks/chest/oak.zig.zon
index ac384d43..ee9eea4e 100644
--- a/assets/cubyz/blocks/chest/oak.zig.zon
+++ b/assets/cubyz/blocks/chest/oak.zig.zon
@@ -1,8 +1,12 @@
 .{
 	.texture = "cubyz:chest/oak/back",
-	.texture_front = "cubyz:chest/oak/front",
+	.texture_front = "cubyz:chest/oak/front_latch",
 	.texture_left = "cubyz:chest/oak/side",
 	.texture_right = "cubyz:chest/oak/side",
 	.texture_top = "cubyz:chest/oak/top",
 	.texture_bottom = "cubyz:chest/oak/bottom",
+	.texture6 = "cubyz:chest/oak/inside_body",
+	.texture7 = "cubyz:chest/oak/inside_lid",
+	.texture8 = "cubyz:chest/oak/front_nolatch",
+	.texture9 = "cubyz:chest/oak/latch",
 }
diff --git a/assets/cubyz/blocks/chest/pine.zig.zon b/assets/cubyz/blocks/chest/pine.zig.zon
index 0357495a..3fcd7503 100644
--- a/assets/cubyz/blocks/chest/pine.zig.zon
+++ b/assets/cubyz/blocks/chest/pine.zig.zon
@@ -5,4 +5,6 @@
 	.texture_right = "cubyz:chest/pine/side",
 	.texture_top = "cubyz:chest/pine/top",
 	.texture_bottom = "cubyz:chest/pine/bottom",
+	.texture6 = "cubyz:void_stone",
+	.texture7 = "cubyz:void_stone",
 }
diff --git a/assets/cubyz/blocks/chest/willow.zig.zon b/assets/cubyz/blocks/chest/willow.zig.zon
index 2c1f3489..0df42bc8 100644
--- a/assets/cubyz/blocks/chest/willow.zig.zon
+++ b/assets/cubyz/blocks/chest/willow.zig.zon
@@ -5,4 +5,6 @@
 	.texture_right = "cubyz:chest/willow/side",
 	.texture_top = "cubyz:chest/willow/top",
 	.texture_bottom = "cubyz:chest/willow/bottom",
+	.texture6 = "cubyz:void_stone",
+	.texture7 = "cubyz:void_stone",
 }
diff --git a/assets/cubyz/models/chest_lid.obj b/assets/cubyz/models/chest_lid.obj
new file mode 100644
index 00000000..a84cfbe6
--- /dev/null
+++ b/assets/cubyz/models/chest_lid.obj
@@ -0,0 +1,46 @@
+v 1 1 0.25
+v 1 0 0.25
+v 0 1 0.25
+v 0 0 0.25
+v 0 1 0
+v 0 0 0
+v 1 1 0
+v 1 0 0
+v 1 1.001 -0.75
+v 0 1.001 -0.75
+v 1 1.001 0.25
+v 0 1.001 0.25
+vt 0 0.25
+vt 0 0
+vt 0.25 0
+vt 0.25 0.25
+vt 0.75 0.5
+vt 0.75 0.25
+vt 1 0.25
+vt 1 0.5
+vt 0.5 0.25
+vt 0.5 0.1875
+vt 0.75 0.1875
+vt 1 0.1875
+vt 0 0.75
+vt 0 0.6875
+vt 0.25 0.6875
+vt 0.25 0.75
+vt 0.25 0.5
+vt 0.25 0.4375
+vt 0.5 0.4375
+vt 0.5 0.5
+vt 0.5 0.75
+vn 0 0 1
+vn 0 0 -1
+vn 1 0 0
+vn -1 0 0
+vn 0 1 0
+vn 0 -1 0
+f 2/1/1 1/2/1 3/3/1 4/4/1
+f 6/5/2 5/6/2 7/7/2 8/8/2
+f 2/9/3 8/10/3 7/11/3 1/6/3
+f 3/6/4 5/11/4 6/12/4 4/7/4
+f 1/13/5 7/14/5 5/15/5 3/16/5
+f 4/17/6 6/18/6 8/19/6 2/20/6
+f 9/17/5 10/20/5 12/21/5 11/16/5
diff --git a/assets/cubyz/models/open_chest.obj b/assets/cubyz/models/open_chest.obj
new file mode 100644
index 00000000..6b852a26
--- /dev/null
+++ b/assets/cubyz/models/open_chest.obj
@@ -0,0 +1,38 @@
+v 1 1 0.75
+v 1 0 0.75
+v 0 1 0.75
+v 0 0 0.75
+v 0 1 0
+v 0 0 0
+v 1 1 0
+v 1 0 0
+vt 0.5 0.5
+vt 0.5 0.25
+vt 0.75 0.25
+vt 0.75 0.5
+vt 0.25 0.25
+vt 0.25 0
+vt 0.5 0
+vt 0.5 0.1875
+vt 0.75 0
+vt 0.75 0.1875
+vt 1 0
+vt 1 0.1875
+vt 0 0.6875
+vt 0 0.5
+vt 0.25 0.5
+vt 0.25 0.6875
+vt 0.25 0.4375
+vt 0.5 0.4375
+vn 0 0 1
+vn 0 0 -1
+vn 1 0 0
+vn -1 0 0
+vn 0 1 0
+vn 0 -1 0
+f 2/1/1 1/2/1 3/3/1 4/4/1
+f 6/5/2 5/6/2 7/7/2 8/2/2
+f 2/8/3 8/7/3 7/9/3 1/10/3
+f 3/10/4 5/9/4 6/11/4 4/12/4
+f 1/13/5 7/14/5 5/15/5 3/16/5
+f 4/17/6 6/5/6 8/2/6 2/18/6
diff --git a/assets/cubyz/shaders/block_entity/chest.frag b/assets/cubyz/shaders/block_entity/chest.frag
new file mode 100644
index 00000000..8515a0bc
--- /dev/null
+++ b/assets/cubyz/shaders/block_entity/chest.frag
@@ -0,0 +1,72 @@
+#version 460
+
+layout(location = 0) in vec3 mvVertexPos;
+layout(location = 1) in vec3 direction;
+layout(location = 2) in vec3 light;
+layout(location = 3) in vec2 uv;
+layout(location = 4) flat in vec3 normal;
+layout(location = 5) flat in int textureIndex;
+layout(location = 6) flat in int isBackFace;
+layout(location = 7) flat in float distanceForLodCheck;
+layout(location = 8) flat in int opaqueInLod;
+
+layout(location = 0) out vec4 fragColor;
+
+layout(binding = 0) uniform sampler2DArray textureSampler;
+layout(binding = 1) uniform sampler2DArray emissionSampler;
+layout(binding = 2) uniform sampler2DArray reflectivityAndAbsorptionSampler;
+layout(binding = 4) uniform samplerCube reflectionMap;
+layout(binding = 5) uniform sampler2D ditherTexture;
+
+layout(location = 5) uniform float reflectionMapSize;
+layout(location = 6) uniform float contrast;
+layout(location = 7) uniform float lodDistance;
+
+layout(std430, binding = 1) buffer _animatedTexture
+{
+	float animatedTexture[];
+};
+
+float lightVariation(vec3 normal) {
+	const vec3 directionalPart = vec3(0, contrast/2, contrast);
+	const float baseLighting = 1 - contrast;
+	return baseLighting + dot(normal, directionalPart);
+}
+
+bool passDitherTest(float alpha) {
+	if(opaqueInLod != 0) {
+		if(distanceForLodCheck > lodDistance) return true;
+		float factor = max(0, distanceForLodCheck - (lodDistance - 32.0))/32.0;
+		alpha = alpha*(1 - factor) + factor;
+	}
+	return alpha > texture(ditherTexture, uv).r*255.0/256.0 + 0.5/256.0;
+}
+
+vec4 fixedCubeMapLookup(vec3 v) { // Taken from http://the-witness.net/news/2012/02/seamless-cube-map-filtering/
+	float M = max(max(abs(v.x), abs(v.y)), abs(v.z));
+	float scale = (reflectionMapSize - 1)/reflectionMapSize;
+	if (abs(v.x) != M) v.x *= scale;
+	if (abs(v.y) != M) v.y *= scale;
+	if (abs(v.z) != M) v.z *= scale;
+	return texture(reflectionMap, v);
+}
+
+void main() {
+	float animatedTextureIndex = animatedTexture[textureIndex];
+	float normalVariation = lightVariation(normal);
+	vec3 textureCoords = vec3(uv, animatedTextureIndex);
+
+	float reflectivity = texture(reflectivityAndAbsorptionSampler, textureCoords).a;
+	float fresnelReflection = (1 + dot(normalize(direction), normal));
+	fresnelReflection *= fresnelReflection;
+	fresnelReflection *= min(1, 2*reflectivity); // Limit it to 2*reflectivity to avoid making every block reflective.
+	reflectivity = reflectivity*fixedCubeMapLookup(reflect(direction, normal)).x;
+	reflectivity = reflectivity*(1 - fresnelReflection) + fresnelReflection;
+
+	vec3 pixelLight = max(light*normalVariation, texture(emissionSampler, textureCoords).r*4);
+	fragColor = texture(textureSampler, textureCoords)*vec4(pixelLight, 1);
+	fragColor.rgb += reflectivity*pixelLight;
+
+	if(!passDitherTest(fragColor.a)) discard;
+	fragColor.a = 1;
+}
diff --git a/assets/cubyz/shaders/block_entity/chest.vert b/assets/cubyz/shaders/block_entity/chest.vert
new file mode 100644
index 00000000..a7146aa9
--- /dev/null
+++ b/assets/cubyz/shaders/block_entity/chest.vert
@@ -0,0 +1,113 @@
+#version 460
+
+layout(location = 0) out vec3 mvVertexPos;
+layout(location = 1) out vec3 direction;
+layout(location = 2) out vec3 light;
+layout(location = 3) out vec2 uv;
+layout(location = 4) flat out vec3 normal;
+layout(location = 5) flat out int textureIndex;
+layout(location = 6) flat out int isBackFace;
+layout(location = 7) flat out float distanceForLodCheck;
+layout(location = 8) flat out int opaqueInLod;
+
+layout(location = 0) uniform vec3 ambientLight;
+layout(location = 1) uniform mat4 projectionMatrix;
+layout(location = 2) uniform mat4 viewMatrix;
+layout(location = 3) uniform ivec3 playerPositionInteger;
+layout(location = 4) uniform vec3 playerPositionFraction;
+layout(location = 8) uniform mat4 modelMatrix;
+
+struct FaceData {
+	int encodedPositionAndLightIndex;
+	int textureAndQuad;
+};
+layout(std430, binding = 3) buffer _faceData
+{
+	FaceData faceData[];
+};
+
+struct QuadInfo {
+	vec3 normal;
+	float corners[4][3];
+	vec2 cornerUV[4];
+	uint textureSlot;
+	int opaqueInLod;
+};
+
+layout(std430, binding = 4) buffer _quads
+{
+	QuadInfo quads[];
+};
+
+layout(std430, binding = 10) buffer _lightData
+{
+	uint lightData[];
+};
+
+struct ChunkData {
+	ivec4 position;
+	vec4 minPos;
+	vec4 maxPos;
+	int voxelSize;
+	uint lightStart;
+	uint vertexStartOpaque;
+	uint faceCountsByNormalOpaque[14];
+	uint vertexStartTransparent;
+	uint vertexCountTransparent;
+	uint visibilityState;
+	uint oldVisibilityState;
+};
+
+layout(std430, binding = 6) buffer _chunks
+{
+	ChunkData chunks[];
+};
+
+void main() {
+	int faceID = gl_VertexID >> 2;
+	int vertexID = gl_VertexID & 3;
+	int chunkID = gl_BaseInstance;
+	int voxelSize = chunks[chunkID].voxelSize;
+	int encodedPositionAndLightIndex = faceData[faceID].encodedPositionAndLightIndex;
+	int textureAndQuad = faceData[faceID].textureAndQuad;
+	uint lightIndex = chunks[chunkID].lightStart + 4*(encodedPositionAndLightIndex >> 16);
+	uint fullLight = lightData[lightIndex + vertexID];
+	vec3 sunLight = vec3(
+		fullLight >> 25 & 31u,
+		fullLight >> 20 & 31u,
+		fullLight >> 15 & 31u
+	);
+	vec3 blockLight = vec3(
+		fullLight >> 10 & 31u,
+		fullLight >> 5 & 31u,
+		fullLight >> 0 & 31u
+	);
+	light = max(sunLight*ambientLight, blockLight)/31;
+	isBackFace = encodedPositionAndLightIndex>>15 & 1;
+
+	textureIndex = textureAndQuad & 65535;
+	int quadIndex = textureAndQuad >> 16;
+
+	vec3 position = vec3(
+		encodedPositionAndLightIndex & 31,
+		encodedPositionAndLightIndex >> 5 & 31,
+		encodedPositionAndLightIndex >> 10 & 31
+	);
+
+	normal = quads[quadIndex].normal;
+
+	position += (vec4(quads[quadIndex].corners[vertexID][0], quads[quadIndex].corners[vertexID][1], quads[quadIndex].corners[vertexID][2], 1)).xyz;
+	position = (modelMatrix*vec4(position - vec3(1), 1)).xyz + vec3(1);
+	position *= voxelSize;
+	position += vec3(chunks[chunkID].position.xyz - playerPositionInteger);
+	position -= playerPositionFraction;
+
+	direction = position;
+
+	vec4 mvPos = viewMatrix*vec4(position, 1);
+	gl_Position = projectionMatrix*mvPos;
+	mvVertexPos = mvPos.xyz;
+	distanceForLodCheck = length(mvPos.xyz) + voxelSize;
+	uv = quads[quadIndex].cornerUV[vertexID]*voxelSize;
+	opaqueInLod = quads[quadIndex].opaqueInLod;
+}
diff --git a/mods/cubyz/rotation/chest.zig b/mods/cubyz/rotation/chest.zig
new file mode 100644
index 00000000..54f8bc3d
--- /dev/null
+++ b/mods/cubyz/rotation/chest.zig
@@ -0,0 +1,106 @@
+const std = @import("std");
+
+const main = @import("main");
+const blocks = main.blocks;
+const Block = blocks.Block;
+const Neighbor = main.chunk.Neighbor;
+const ModelIndex = main.models.ModelIndex;
+const rotation = main.rotation;
+const Degrees = rotation.Degrees;
+const vec = main.vec;
+const Mat4f = vec.Mat4f;
+const Vec3f = vec.Vec3f;
+const Vec3i = vec.Vec3i;
+const ZonElement = main.ZonElement;
+
+var rotatedModels: std.StringHashMap(ModelIndex) = undefined;
+
+pub fn init() void {
+	rotatedModels = .init(main.globalAllocator.allocator);
+}
+
+pub fn deinit() void {
+	var iterator = rotatedModels.keyIterator();
+	while(iterator.next()) |key| {
+		main.globalAllocator.free(key.*);
+	}
+	rotatedModels.deinit();
+}
+
+pub fn reset() void {
+	var iterator = rotatedModels.keyIterator();
+	while(iterator.next()) |key| {
+		main.globalAllocator.free(key.*);
+	}
+	rotatedModels.clearRetainingCapacity();
+}
+
+pub fn createBlockModel(_: Block, _: *u16, zon: ZonElement) ModelIndex {
+	const closedId = zon.get([]const u8, "closed", "cubyz:cube");
+	const openId = zon.get([]const u8, "open", "cubyz:cube");
+	const lidId = zon.get([]const u8, "lid", "cubyz:cube");
+	const joinedId = std.fmt.allocPrint(main.globalAllocator.allocator, "{s}:{s}:{s}", .{closedId, openId, lidId}) catch unreachable;
+	if(rotatedModels.get(joinedId)) |modelIndex| {
+		main.globalAllocator.free(joinedId);
+		return modelIndex;
+	}
+
+	const closedModel = main.models.getModelIndex(closedId).model();
+	// Rotate the model:
+	const modelIndex: ModelIndex = closedModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(std.math.pi/2.0)});
+	_ = closedModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(-std.math.pi/2.0)});
+	_ = closedModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(std.math.pi)});
+	_ = closedModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.identity()});
+
+	const openModel = main.models.getModelIndex(openId).model();
+
+	_ = openModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(std.math.pi/2.0)});
+	_ = openModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(-std.math.pi/2.0)});
+	_ = openModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(std.math.pi)});
+	_ = openModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.identity()});
+
+	const lidModel = main.models.getModelIndex(lidId).model();
+
+	_ = lidModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.identity()});
+
+	rotatedModels.put(joinedId, modelIndex) catch unreachable;
+	return modelIndex;
+}
+
+pub fn model(block: Block) ModelIndex {
+	return blocks.meshes.modelIndexStart(block).add(@min(block.data, 8));
+}
+
+pub fn rotateZ(data: u16, angle: Degrees) u16 {
+	comptime var rotationTable: [4][4]u8 = undefined;
+	comptime for(0..4) |i| {
+		rotationTable[0][i] = i;
+	};
+	comptime for(1..4) |a| {
+		for(0..4) |i| {
+			const neighbor: Neighbor = @enumFromInt(rotationTable[a - 1][i] + 2);
+			rotationTable[a][i] = neighbor.rotateZ().toInt() - 2;
+		}
+	};
+	if(data >= 8) return 0;
+	return rotationTable[@intFromEnum(angle)][data & 3] | (data & 4);
+}
+
+pub fn generateData(_: *main.game.World, _: Vec3i, _: Vec3f, playerDir: Vec3f, _: Vec3i, _: ?Neighbor, currentData: *Block, _: Block, blockPlacing: bool) bool {
+	if(blockPlacing) {
+		if(@abs(playerDir[0]) > @abs(playerDir[1])) {
+			const dir: Neighbor = if(playerDir[0] < 0) .dirNegX else .dirPosX;
+			currentData.data = dir.toInt() - 2;
+		} else {
+			const dir: Neighbor = if(playerDir[1] < 0) .dirNegY else .dirPosY;
+			currentData.data = dir.toInt() - 2;
+		}
+		return true;
+	}
+	return false;
+}
+
+pub fn canBeChangedInto(oldBlock: Block, newBlock: Block, item: main.items.ItemStack, shouldDropSourceBlockOnSuccess: *bool) rotation.RotationMode.CanBeChangedInto {
+	if(oldBlock.typ == newBlock.typ) return .yes;
+	return rotation.RotationMode.DefaultFunctions.canBeChangedInto(oldBlock, newBlock, item, shouldDropSourceBlockOnSuccess);
+}
\ No newline at end of file
diff --git a/src/Inventory.zig b/src/Inventory.zig
index 3e2efdfe..ea7dd943 100644
--- a/src/Inventory.zig
+++ b/src/Inventory.zig
@@ -448,8 +448,8 @@ pub const Sync = struct { // MARK: Sync
 			return null;
 		}
 
-		pub fn getInventoryFromId(serverId: InventoryId) Inventory {
-			return inventories.items[@intFromEnum(serverId)].inv;
+		pub fn getServerInventoryFromId(serverId: InventoryId) ServerInventory {
+			return inventories.items[@intFromEnum(serverId)];
 		}
 
 		pub fn clearPlayerInventory(user: *main.server.User) void {
diff --git a/src/block_entity.zig b/src/block_entity.zig
index 71c4f883..ecc4e10f 100644
--- a/src/block_entity.zig
+++ b/src/block_entity.zig
@@ -194,16 +194,56 @@ pub const BlockEntityTypes = struct {
 		const StorageServer = BlockEntityDataStorage(struct {
 			invId: main.items.Inventory.InventoryId,
 		});
+		const StorageClient = BlockEntityDataStorage(struct {
+			pos: Vec3i,
+			angle: f32,
+			shouldBeOpen: bool,
+		});
+
+		var pipeline: graphics.Pipeline = undefined;
+		var uniforms: struct {
+			projectionMatrix: c_int,
+			viewMatrix: c_int,
+			modelMatrix: c_int,
+			playerPositionInteger: c_int,
+			playerPositionFraction: c_int,
+			screenSize: c_int,
+			ambientLight: c_int,
+			contrast: c_int,
+			@"fog.color": c_int,
+			@"fog.density": c_int,
+			@"fog.fogLower": c_int,
+			@"fog.fogHigher": c_int,
+			reflectionMapSize: c_int,
+			lodDistance: c_int,
+			zNear: c_int,
+			zFar: c_int,
+		} = undefined;
 
 		pub const id = "chest";
 		pub fn init() void {
 			StorageServer.init();
+			StorageClient.init();
+			lastUpdateTime = std.time.milliTimestamp();
+			pipeline = graphics.Pipeline.init(
+				"assets/cubyz/shaders/block_entity/chest.vert",
+				"assets/cubyz/shaders/block_entity/chest.frag",
+				"",
+				&uniforms,
+				.{},
+				.{.depthTest = true, .depthWrite = true},
+				.{.attachments = &.{.noBlending}},
+			);
 		}
 		pub fn deinit() void {
 			StorageServer.deinit();
+			StorageClient.deinit();
+			pipeline.deinit();
 		}
 		pub fn reset() void {
 			StorageServer.reset();
+			StorageClient.reset();
+			lastUpdateTime = std.time.milliTimestamp();
 		}
 
 		fn onInventoryUpdateCallback(source: main.items.Inventory.Source) void {
@@ -216,12 +256,32 @@ pub const BlockEntityTypes = struct {
 			ch.setChanged();
 		}
 
-		const inventoryCallbacks = main.items.Inventory.Callbacks{
+		fn onInventoryOpenCallback(source: main.items.Inventory.Source) void {
+			var block = main.server.world.?.getBlock(source.blockInventory[0], source.blockInventory[1], source.blockInventory[2]) orelse return;
+			block.data |= 4;
+			main.server.world.?.updateBlock(source.blockInventory[0], source.blockInventory[1], source.blockInventory[2], block);
+			main.network.Protocols.blockEntityUpdate.sendServerDataUpdateToClients(source.blockInventory);
+		}
+
+		fn onInventoryClosedCallback(source: main.items.Inventory.Source) void {
+			main.network.Protocols.blockEntityUpdate.sendServerDataUpdateToClients(source.blockInventory);
+		}
+
+		const inventoryCallbacks: main.items.Inventory.Callbacks = .{
 			.onUpdateCallback = &onInventoryUpdateCallback,
+			.onFirstOpenCallback = &onInventoryOpenCallback,
+			.onLastCloseCallback = &onInventoryClosedCallback,
 		};
 
-		pub fn onLoadClient(_: Vec3i, _: *Chunk, _: *BinaryReader) BinaryReader.AllErrors!void {}
-		pub fn onUnloadClient(_: BlockEntityIndex) void {}
+		pub fn onLoadClient(pos: Vec3i, chunk: *Chunk, reader: *BinaryReader) BinaryReader.AllErrors!void {
+			return updateClientData(pos, chunk, .{.update = reader});
+		}
+		pub fn onUnloadClient(dataIndex: BlockEntityIndex) void {
+			StorageClient.mutex.lock();
+			defer StorageClient.mutex.unlock();
+			_ = StorageClient.removeAtIndex(dataIndex) orelse unreachable;
+		}
+
 		pub fn onLoadServer(pos: Vec3i, chunk: *Chunk, reader: *BinaryReader) BinaryReader.AllErrors!void {
 			StorageServer.mutex.lock();
 			defer StorageServer.mutex.unlock();
@@ -237,20 +297,28 @@ pub const BlockEntityTypes = struct {
 			StorageServer.mutex.unlock();
 			main.items.Inventory.Sync.ServerSide.destroyExternallyManagedInventory(data.invId);
 		}
+		pub fn onStoreServerToClient(dataIndex: BlockEntityIndex, writer: *BinaryWriter) void {
+			StorageServer.mutex.lock();
+			defer StorageServer.mutex.unlock();
+			const data = StorageServer.getByIndex(dataIndex) orelse return;
+
+			const hasClients = main.items.Inventory.Sync.ServerSide.getServerInventoryFromId(data.invId).users.items.len != 0;
+
+			writer.writeInt(u1, @intFromBool(hasClients));
+		}
 		pub fn onStoreServerToDisk(dataIndex: BlockEntityIndex, writer: *BinaryWriter) void {
 			StorageServer.mutex.lock();
 			defer StorageServer.mutex.unlock();
 			const data = StorageServer.getByIndex(dataIndex) orelse return;
 
-			const inv = main.items.Inventory.Sync.ServerSide.getInventoryFromId(data.invId);
+			const inv = main.items.Inventory.Sync.ServerSide.getServerInventoryFromId(data.invId);
 			var isEmpty: bool = true;
-			for(inv._items) |item| {
+			for(inv.inv._items) |item| {
 				if(item.amount != 0) isEmpty = false;
 			}
 			if(isEmpty) return;
-			inv.toBytes(writer);
+			inv.inv.toBytes(writer);
 		}
-		pub fn onStoreServerToClient(_: BlockEntityIndex, _: *BinaryWriter) void {}
 		pub fn onInteract(pos: Vec3i, _: *Chunk) EventStatus {
 			if(main.KeyBoard.key("shift").pressed) return .ignored;
 
@@ -265,7 +333,24 @@ pub const BlockEntityTypes = struct {
 			return .handled;
 		}
 
-		pub fn updateClientData(_: Vec3i, _: *Chunk, _: UpdateEvent) BinaryReader.AllErrors!void {}
+		pub fn updateClientData(pos: Vec3i, chunk: *Chunk, event: UpdateEvent) BinaryReader.AllErrors!void {
+			if(event == .remove) {
+				_ = StorageClient.remove(pos, chunk) orelse return;
+				return;
+			}
+
+			StorageClient.mutex.lock();
+			defer StorageClient.mutex.unlock();
+
+			const data = StorageClient.getOrPut(pos, chunk);
+			if(!data.foundExisting) {
+				data.valuePtr.* = .{.angle = 0, .pos = pos, .shouldBeOpen = false};
+			}
+			if(event.update.remaining.len != 0) {
+				data.valuePtr.shouldBeOpen = try event.update.readInt(u1) != 0;
+			}
+		}
+
 		pub fn updateServerData(pos: Vec3i, chunk: *Chunk, event: UpdateEvent) BinaryReader.AllErrors!void {
 			switch(event) {
 				.remove => {
@@ -282,10 +367,149 @@ pub const BlockEntityTypes = struct {
 				},
 			}
 		}
-		pub fn getServerToClientData(_: Vec3i, _: *Chunk, _: *BinaryWriter) void {}
+
+		pub fn getServerToClientData(pos: Vec3i, chunk: *Chunk, writer: *BinaryWriter) void {
+			StorageServer.mutex.lock();
+			defer StorageServer.mutex.unlock();
+
+			const data = StorageServer.get(pos, chunk) orelse return;
+
+			const hasClients = main.items.Inventory.Sync.ServerSide.getServerInventoryFromId(data.invId).users.items.len != 0;
+
+			writer.writeInt(u1, @intFromBool(hasClients));
+		}
+
 		pub fn getClientToServerData(_: Vec3i, _: *Chunk, _: *BinaryWriter) void {}
 
-		pub fn renderAll(_: Mat4f, _: Vec3f, _: Vec3d) void {}
+		var lastUpdateTime: i64 = 0;
+		pub fn renderAll(projMatrix: Mat4f, ambientLight: Vec3f, playerPosition: Vec3d) void {
+			const newTime = std.time.milliTimestamp();
+			const deltaTime = @as(f32, @floatFromInt(newTime - lastUpdateTime))/1000.0;
+			lastUpdateTime = newTime;
+
+			StorageClient.mutex.lock();
+			defer StorageClient.mutex.unlock();
+
+			for(StorageClient.storage.dense.items) |*chest| {
+				var block = main.renderer.mesh_storage.getBlockFromRenderThread(chest.pos[0], chest.pos[1], chest.pos[2]) orelse continue;
+
+				if(block.data >= 4) {
+					if(chest.shouldBeOpen) {
+						chest.angle += deltaTime*270.0;
+						if(chest.angle > 90.0) {
+							chest.angle = 90.0;
+						}
+					} else {
+						chest.angle -= deltaTime*270.0;
+						if(chest.angle < 0.0) {
+							chest.angle = 0.0;
+							const newBlock = main.blocks.Block{.typ = block.typ, .data = block.data & 3};
+							main.renderer.MeshSelection.updateBlockAndSendUpdate(main.game.Player.inventory, 0, chest.pos[0], chest.pos[1], chest.pos[2], block, newBlock);
+							continue;
+						}
+					}
+
+					const rotation: f32 = switch(block.data & 3) {
+						0 => std.math.pi/2.0,
+						1 => -std.math.pi/2.0,
+						2 => std.math.pi,
+						3 => 0,
+						else => unreachable,
+					};
+					block.data = 4;
+					const height = main.blocks.meshes.model(block).model().max[2];
+					var modelMatrix = Mat4f.translation(.{0, 0, height});
+					modelMatrix = modelMatrix.mul(Mat4f.translation(.{0.5, 0.5, 0}));
+					modelMatrix = modelMatrix.mul(Mat4f.rotationZ(rotation));
+					modelMatrix = modelMatrix.mul(Mat4f.translation(.{-0.5, -0.5, 0}));
+					modelMatrix = modelMatrix.mul(Mat4f.rotationX(std.math.degreesToRadians(chest.angle)));
+					block.data = 8;
+
+					var faceData: main.ListUnmanaged(main.renderer.chunk_meshing.FaceData) = .{};
+					defer faceData.deinit(main.stackAllocator);
+					const model = main.blocks.meshes.model(block).model();
+					if(block.hasBackFace()) {
+						model.appendInternalQuadsToList(&faceData, main.stackAllocator, block, 1, 1, 1, true);
+						for(main.chunk.Neighbor.iterable) |neighbor| {
+							model.appendNeighborFacingQuadsToList(&faceData, main.stackAllocator, block, neighbor, 1, 1, 1, true);
+						}
+					}
+					model.appendInternalQuadsToList(&faceData, main.stackAllocator, block, 1, 1, 1, false);
+					for(main.chunk.Neighbor.iterable) |neighbor| {
+						model.appendNeighborFacingQuadsToList(&faceData, main.stackAllocator, block, neighbor, 1 + neighbor.relX(), 1 + neighbor.relY(), 1 + neighbor.relZ(), false);
+					}
+
+					for(faceData.items) |*face| {
+						face.position.lightIndex = 0;
+					}
+					var allocation: graphics.SubAllocation = .{.start = 0, .len = 0};
+					main.renderer.chunk_meshing.faceBuffers[0].uploadData(faceData.items, &allocation);
+					defer main.renderer.chunk_meshing.faceBuffers[0].free(allocation);
+					var lightAllocation: graphics.SubAllocation = .{.start = 0, .len = 0};
+					var lightVals: [6]u8 = main.renderer.mesh_storage.getLight(chest.pos[0], chest.pos[1], chest.pos[2]) orelse @splat(0);
+					inline for(&lightVals) |*val| {
+						val.* = @as(u8, @intFromFloat(@as(f32, @floatFromInt(val.*))*0.8));
+					}
+					const light = (@as(u32, lightVals[0] >> 3) << 25 |
+						@as(u32, lightVals[1] >> 3) << 20 |
+						@as(u32, lightVals[2] >> 3) << 15 |
+						@as(u32, lightVals[3] >> 3) << 10 |
+						@as(u32, lightVals[4] >> 3) << 5 |
+						@as(u32, lightVals[5] >> 3) << 0);
+					main.renderer.chunk_meshing.lightBuffers[0].uploadData(&.{light, light, light, light}, &lightAllocation);
+					defer main.renderer.chunk_meshing.lightBuffers[0].free(lightAllocation);
+
+					var chunkAllocation: graphics.SubAllocation = .{.start = 0, .len = 0};
+					main.renderer.chunk_meshing.chunkBuffer.uploadData(&.{.{
+						.position = .{0, 0, 0},
+						.min = undefined,
+						.max = undefined,
+						.voxelSize = 1,
+						.lightStart = lightAllocation.start,
+						.vertexStartOpaque = undefined,
+						.faceCountsByNormalOpaque = undefined,
+						.vertexStartTransparent = undefined,
+						.vertexCountTransparent = undefined,
+						.visibilityState = 0,
+						.oldVisibilityState = 0,
+					}}, &chunkAllocation);
+					defer main.renderer.chunk_meshing.chunkBuffer.free(chunkAllocation);
+
+					pipeline.bind(null);
+					c.glUniformMatrix4fv(uniforms.projectionMatrix, 1, c.GL_TRUE, @ptrCast(&projMatrix));
+
+					c.glUniform1f(uniforms.reflectionMapSize, main.renderer.reflectionCubeMapSize);
+
+					c.glUniform1f(uniforms.contrast, 0);
+
+					c.glUniform1f(uniforms.lodDistance, main.settings.@"lod0.5Distance");
+
+					c.glUniformMatrix4fv(uniforms.viewMatrix, 1, c.GL_TRUE, @ptrCast(&main.game.camera.viewMatrix));
+
+					c.glUniform3f(uniforms.ambientLight, ambientLight[0], ambientLight[1], ambientLight[2]);
+
+					c.glUniform1f(uniforms.zNear, main.renderer.zNear);
+					c.glUniform1f(uniforms.zFar, main.renderer.zFar);
+
+					const playerPos = playerPosition - @as(Vec3d, @floatFromInt(chest.pos)) + Vec3d{1, 1, 1};
+					c.glUniform3i(uniforms.playerPositionInteger, @intFromFloat(@floor(playerPos[0])), @intFromFloat(@floor(playerPos[1])), @intFromFloat(@floor(playerPos[2])));
+					c.glUniform3f(uniforms.playerPositionFraction, @floatCast(@mod(playerPos[0], 1)), @floatCast(@mod(playerPos[1], 1)), @floatCast(@mod(playerPos[2], 1)));
+					c.glUniformMatrix4fv(uniforms.modelMatrix, 1, c.GL_TRUE, @ptrCast(&modelMatrix));
+
+					c.glBindVertexArray(main.renderer.chunk_meshing.vao);
+
+					main.renderer.chunk_meshing.faceBuffers[0].ssbo.bind(main.renderer.chunk_meshing.faceBuffers[0].binding);
+					main.renderer.chunk_meshing.lightBuffers[0].ssbo.bind(main.renderer.chunk_meshing.lightBuffers[0].binding);
+					c.glActiveTexture(c.GL_TEXTURE0);
+					main.blocks.meshes.blockTextureArray.bind();
+					c.glActiveTexture(c.GL_TEXTURE1);
+					main.blocks.meshes.emissionTextureArray.bind();
+					c.glActiveTexture(c.GL_TEXTURE2);
+					main.blocks.meshes.reflectivityAndAbsorptionTextureArray.bind();
+					c.glDrawElementsInstancedBaseVertexBaseInstance(c.GL_TRIANGLES, @intCast(6*faceData.items.len), c.GL_UNSIGNED_INT, null, 1, allocation.start*4, chunkAllocation.start);
+				}
+			}
+		}
 	};
 
 	pub const Sign = struct {
diff --git a/src/gui/windows/chest.zig b/src/gui/windows/chest.zig
index 54ec4a5e..6845288e 100644
--- a/src/gui/windows/chest.zig
+++ b/src/gui/windows/chest.zig
@@ -4,6 +4,7 @@ const main = @import("main");
 const Player = main.game.Player;
 const ItemStack = main.items.ItemStack;
 const Vec2f = main.vec.Vec2f;
+const Vec3i = main.vec.Vec3i;
 const Texture = main.graphics.Texture;
 
 const gui = @import("../gui.zig");
@@ -37,9 +38,12 @@ pub fn deinit() void {
 	itemSlots.deinit();
 }
 
-pub var openInventory: main.items.Inventory = undefined;
+var openPos: Vec3i = undefined;
+var openInventory: main.items.Inventory = undefined;
 
 pub fn setInventory(selectedInventory: main.items.Inventory) void {
+	std.debug.assert(selectedInventory.source == .blockInventory);
+	openPos = selectedInventory.source.blockInventory;
 	openInventory = selectedInventory;
 }
 
diff --git a/src/renderer.zig b/src/renderer.zig
index f7dfa7a2..3b8dc5ee 100644
--- a/src/renderer.zig
+++ b/src/renderer.zig
@@ -58,7 +58,7 @@ var fakeReflectionUniforms: struct {
 pub var activeFrameBuffer: c_uint = 0;
 
 pub const reflectionCubeMapSize = 64;
-var reflectionCubeMap: graphics.CubeMapTexture = undefined;
+pub var reflectionCubeMap: graphics.CubeMapTexture = undefined;
 
 pub fn init() void {
 	deferredRenderPassPipeline = graphics.Pipeline.init(
@@ -1106,7 +1106,7 @@ pub const MeshSelection = struct { // MARK: MeshSelection
 		}
 	}
 
-	fn updateBlockAndSendUpdate(source: main.items.Inventory, slot: u32, x: i32, y: i32, z: i32, oldBlock: blocks.Block, newBlock: blocks.Block) void {
+	pub fn updateBlockAndSendUpdate(source: main.items.Inventory, slot: u32, x: i32, y: i32, z: i32, oldBlock: blocks.Block, newBlock: blocks.Block) void {
 		main.items.Inventory.Sync.ClientSide.executeCommand(.{
 			.updateBlock = .{
 				.source = .{.inv = source, .slot = slot},
diff --git a/src/renderer/chunk_meshing.zig b/src/renderer/chunk_meshing.zig
index 06c241c0..2c2719c1 100644
--- a/src/renderer/chunk_meshing.zig
+++ b/src/renderer/chunk_meshing.zig
@@ -24,7 +24,7 @@ const gpu_performance_measuring = main.gui.windowlist.gpu_performance_measuring;
 
 const mesh_storage = @import("mesh_storage.zig");
 
-var pipeline: graphics.Pipeline = undefined;
+pub var pipeline: graphics.Pipeline = undefined;
 var transparentPipeline: graphics.Pipeline = undefined;
 const UniformStruct = struct {
 	projectionMatrix: c_int,
@@ -1262,6 +1262,13 @@ pub const ChunkMesh = struct { // MARK: ChunkMesh
 		}
 		self.mutex.lock();
 		self.chunk.data.setValue(chunk.getIndex(x, y, z), newBlock);
+
+		if(newBlock.blockEntity()) |blockEntity| {
+			var reader = main.utils.BinaryReader.init(blockEntityData);
+			blockEntity.updateClientData(.{_x, _y, _z}, self.chunk, .{.update = &reader}) catch |err| {
+				std.log.err("Got error {s} while trying to create block entity data {any} in position {} for block {s}", .{@errorName(err), blockEntityData, Vec3i{_x, _y, _z}, newBlock.id()});
+			};
+		}
 		self.mutex.unlock();
 
 		self.updateBlockLight(x, y, z, newBlock, lightRefreshList);
diff --git a/src/server/world.zig b/src/server/world.zig
index cf7b7f9c..f62a6528 100644
--- a/src/server/world.zig
+++ b/src/server/world.zig
@@ -1243,7 +1243,7 @@ pub const ServerWorld = struct { // MARK: ServerWorld
 		baseChunk.mutex.lock();
 		defer baseChunk.mutex.unlock();
 
-		if(currentBlock != _newBlock) {
+		if(currentBlock.typ != _newBlock.typ) {
 			if(currentBlock.blockEntity()) |blockEntity| blockEntity.updateServerData(.{wx, wy, wz}, &baseChunk.super, .remove) catch |err| {
 				std.log.err("Got error {s} while trying to remove entity data in position {} for block {s}", .{@errorName(err), Vec3i{wx, wy, wz}, currentBlock.id()});
 			};
